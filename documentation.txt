
schedule package
****************


Module contents
===============

Python job scheduling for humans.

An in-process scheduler for periodic jobs that uses the builder
pattern for configuration. Schedule lets you run Python functions (or
any other callable) periodically at pre-determined intervals using a
simple, human-friendly syntax.

Inspired by Addam Wiggins' article "Rethinking Cron" [1] and the
"clockwork" Ruby module [2][3].

Features:
   * A simple to use API for scheduling jobs.

   * Very lightweight and no external dependencies.

   * Excellent test coverage.

   * Works with Python 2.7 and 3.3

Usage:
   >>> import schedule
   >>> import time

   >>> def job(message='stuff'):
   >>>     print("I'm working on:", message)

   >>> schedule.every(10).minutes.do(job)
   >>> schedule.every().hour.do(job, message='things')
   >>> schedule.every().day.at("10:30").do(job)

   >>> while True:
   >>>     schedule.run_pending()
   >>>     time.sleep(1)

[1] http://adam.heroku.com/past/2010/4/13/rethinking_cron/
[2] https://github.com/tomykaira/clockwork
[3] http://adam.heroku.com/past/2010/6/30/replace_cron_with_clockwork/

class class schedule.CancelJob

   Bases: "object"

class class schedule.Job(interval)

   Bases: "object"

   A periodic job as used by *Scheduler*.

   at(time_str)

      Schedule the job every day at a specific time.

      Calling this is only valid for jobs scheduled to run every N
      day(s).

   day

   days

   do(job_func, *args, **kwargs)

      Specifies the job_func that should be called every time the job
      runs.

      Any additional arguments are passed on to job_func when the job
      runs.

   friday

   hour

   hours

   minute

   minutes

   monday

   run()

      Run the job and immediately reschedule it.

   saturday

   second

   seconds

   should_run

      True if the job should be run now.

   sunday

   thursday

   tuesday

   wednesday

   week

   weeks

class class schedule.Scheduler

   Bases: "object"

   cancel_job(job)

      Delete a scheduled job.

   clear()

      Deletes all scheduled jobs.

   every(interval=1)

      Schedule a new periodic job.

   idle_seconds

      Number of seconds until *next_run*.

   next_run

      Datetime when the next job should run.

   run_all(delay_seconds=0)

      Run all jobs regardless if they are scheduled to run or not.

      A delay of *delay* seconds is added between each job. This helps
      distribute system load generated by the jobs more evenly over
      time.

   run_pending()

      Run all jobs that are scheduled to run.

      Please note that it is *intended behavior that tick() does not
      run missed jobs*. For example, if you've registered a job that
      should run every minute and you only call tick() in one hour
      increments then your job won't be run 60 times in between but
      only once.

schedule.cancel_job(job)

   Delete a scheduled job.

schedule.clear()

   Deletes all scheduled jobs.

schedule.every(interval=1)

   Schedule a new periodic job.

schedule.idle_seconds()

   Number of seconds until *next_run*.

schedule.next_run()

   Datetime when the next job should run.

schedule.run_all(delay_seconds=0)

   Run all jobs regardless if they are scheduled to run or not.

   A delay of *delay* seconds is added between each job. This can help
   to distribute the system load generated by the jobs more evenly
   over time.

schedule.run_pending()

   Run all jobs that are scheduled to run.

   Please note that it is *intended behavior that run_pending() does
   not run missed jobs*. For example, if you've registered a job that
   should run every minute and you only call run_pending() in one hour
   increments then your job won't be run 60 times in between but only
   once.
